<!DOCTYPE html>
<html>
    <head>
        <!-- labeling at various positions works, but is cropped (view box bug) in webkit and is slow in firefox (many objects SVG in HTML in SVG ) -->
        <meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
        <link type="text/css" rel="stylesheet" href="../../css/main.css"/>
        <link type="text/css" rel="stylesheet" href="../../css/labeling.css"/>
        <link type="text/css" rel="stylesheet" href="../../css/labeling-new-boxmodel.css"/>
        <link type="text/css" rel="stylesheet" href="../../css/labeling-webkit-old-boxmodel.css"/>
        <script type="text/javascript" src="../../js/d3.min.js"/></script>
        <!-- own plugins to handle AVM based on D3.js -->
    	<script type="text/javascript" src="../../js/ogvic.js"></script>
        <style type="text/css">
        </style>
    </head>
    <body>
        <div id="labelContainerSpace">
        </div>
        <script type="text/javascript">
        	
						
		/******************************/
		/* CREDITS        			  */
        /******************************/
                    	
        /* after an example from http://jsfiddle.net/Y9Qq3/2/ http://jsfiddle.net/nrabinowitz/VYaGg/2/ */
		
		/******************/
		/* SETTINGS       */
        /******************/
		
        var drawLinks = true; // choose whether only nodes should be drawn and layouted

        var width = 1400,
            height = 1200,
			lineWidth = 7,
        	markerWidth = 3,
            markerHeight = 3,
            cRadius = 10,
			refX = cRadius + (markerWidth * 1.3) + 0.155 * cRadius, /* works well for stroke widths between 5 and 20 */
			// ALT refX = cRadius + (markerWidth * 1.5), 
			// ALT3 refX = cRadius + (markerWidth * 2),
			// ALT1: refX = cRadius + markerWidth * Math.sqrt(lineWidth) ,
			refY = - (cRadius*cRadius) / 375,  /* works well for stroke widths between 5 and 20 */
			// ALT1: refY = -Math.sqrt(cRadius),
			// ALT2: refY = -Math.sqrt(cRadius) * 0.8 + 20/lineWidth, /* works well for stroke width 7px */
            drSub = cRadius + refY, /* works well for stroke widths between 5 and 20 */
			manualArcLabelPositionCorrection = 27, /* works well for stroke widths between 5 and 20 */
			ICONSIZE = 0; // TODO does not actually work. hack!
        	;				 
        
		/******************/
		/* GLOBAL VARS    */
        /******************/
		
        var force = self.force = d3.layout.force()
            .charge(-900)
            .linkDistance(200)
            .size([width, height])
        	;
						
		/******************************/
		/* BASIC PAGE BUILDING        */
        /******************************/
		
		var mInfo = d3.select("body").append("div");
        
        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);
			
		var labelContainerSpace = d3.select("#labelContainerSpace")
			//.style("position","absolute")
			//.attr("id", "labelContainerSpace") // somehow does not work programmatically
		    .attr("width", width)
		    .attr("height", height);
        	
        // Define Markers to be used in arrow paths
        svg.append("svg:defs").selectAll("marker")
           	.data(["arrow", "uml_generalization_arrow"])
            .enter().append("svg:marker")
            .attr("id", String)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", refX)
            .attr("refY", refY)
            .attr("markerWidth", markerWidth)
            .attr("markerHeight", markerHeight)
            .attr("orient", "auto")
            .append("svg:path")
			.attr("markerUnits","userSpaceOnUse") /* seems to have no effect */
            .attr("d", "M0,-5L10,0L0,5L0,-5Z");
			
			
		/**************************/
		/* START DATA DRIVE       */
        /**************************/	
        
        d3.json("../../gen/json/graph-data.json", function(error, graph) {
		//d3.json("../../exampledata/graph-data-1.json", function(error, graph) {
		
			/******************************/
			/* LOCAL(?) FUNCTIONS         */
	        /******************************/
        	
	        var symbolFunction =
			d3.svg.symbol()
	        .size(2*Math.PI*cRadius*cRadius)
	        .type(function (d) {return d.shape_d3_name})
			;
						
		 	var labelSymbolFunction = 
			d3.svg.symbol()
			.size(250)
			.type(function (d) {return d.label_shape_d3_name})
	        ;
				
				
	        	
	        var forceVar = force.nodes(graph.nodes);
			if (drawLinks) {
			  	forceVar.links(graph.links)
			}
	        forceVar.start();
        		  
        		  
    	    /* links/edges with label and tooltip */
    
    		var connectorGroup = svg.selectAll(".connectorGroup")
            .data(graph.links)
            .enter().append("svg:g")
            .attr("class", function (d) { return "connectorGroup link" + d.type; })  
    		;
    		
    		// var path = svg.selectAll(".link")
            //.data(graph.links)
            var path = connectorGroup.append("svg:path")
            .attr("class", function (d) { return "link link" + d.type + " " +  d.arrow_type; })  
    		//.style("stroke", function(d) { return d.color_rgb_hex; })
    		.style("stroke", function(d) { return d.color_rgb_hex_combined; })
    		.attr("marker-end", function (d) {
            	return "url(#" + d.arrow_type + ")";
        	})
        	// approach using mid-markers did not suceed -> a marker on each path-node is not desirable
			/*.attr("marker-mid", function (d) {
    			return "url(#" + "markerSquare" + ")";
        	})*/
			.attr("id", function(d){
            	return d.source.index + "_" + d.target.index;
        	})
    		;
			
			/* label aligned at the connector path */
/*
			 var path_label = svg.append("svg:g")
			 	.selectAll(".path_label")
				.data(force.links()).enter()
		    	.append("svg:text")
				.attr("class", "path_label")
				.append("svg:textPath")
				.attr("startOffset", "50%")
				.attr("text-anchor", "middle")
				.attr("xlink:href", function (d) {
		            return "#" + d.source.index +
		                "_" + d.target.index;
		        }).style("fill", "#fff")
				.style("font-family", "Arial")
				.text(function (d) {
		           		 return d.label;
		        		}
					);*/
					
				/* alternative : simple labeling of connectors */	
        		
        		var connectorLabelGroup = connectorGroup.append("svg:g")
				.attr("class", function(d) { return "connectorLabelGroup" })
        		.attr("class", "label")
        		;
        
				// shapes as reused svg-groups
				 var connectorLabelSymbol = connectorLabelGroup.append("svg:use")
				 .attr("xlink:href", function(d) { return "../../svg/symbols.svg#" + d.shape_d3_name; })
				 .attr("class","svgSymbol")
				 .style("fill", function(d) { return d.color_rgb_hex_combined; })
				 ;
				/*
        		var connectorLabelSymbol = connectorLabelGroup.append("path")
        		 .attr("class", function(d) { return "connectorLabelGroup" })
    			 .attr("d", symbolFunction)
    			 .style("fill", function(d) { return d.color_rgb_hex_combined; })
    			 ;	
    			 */
				
				var connectorLabelText = connectorLabelGroup.append("text")
        		.attr("class", "label")
        	    //.attr("dx", function(d){return 100})
        		//.attr("dy", function(d){return 100})
        	    .text(function(d){return d.label + " (" + d.type + ")" })
        		;
        		
				/* alternative : very simple labeling of connectors by title-tag */	
			
        		//path.append("svg:title")
        	    //  .text(function(d) { return d.label; });

				
				/* manual node positioning */
				
				var node_drag = d3.behavior.drag()
			        .on("dragstart", dragstart)
			        .on("drag", dragmove)
			        .on("dragend", dragend);
					
				function dragstart(d, i) {
			        forceVar.stop() // stops the force auto positioning before you start dragging
			    }
			
			    function dragmove(d, i) {
			        d.px += d3.event.dx;
			        d.py += d3.event.dy;
			        d.x += d3.event.dx;
			        d.y += d3.event.dy; 
			        tick(); // this is the key to make it work together with updating both px,py,x,y on d !
			    }
			
			    function dragend(d, i) {
			        d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
			        tick();
			        forceVar.resume();
			    }

        		  
        	/*
        	  var link = svg.selectAll(".link")
        	      .data(graph.links)
        	    .enter().append("line")
        	      .attr("class", "link")
        	      //.style("stroke-width", function(d) { return Math.sqrt(d.value); })
        		  .style("stroke", function(d) { return d.color_rgb_hex; })
        		  .style("stroke-width", function(d) { return 10 })
        		  ;
        		  */
        	
        	  /* nodes */ 
        	
    			/*Create and place the "blocks" containing the circle and the text */  
				var nodeEnter = svg.selectAll(".node")
        	      .data(graph.nodes).enter()
        	    .append("g")
        		.attr("class", "node")
        	    //.attr("transform", function(d){return "translate("+d.x+",80)"})
        		//.attr("transform", function(d){return "translate(+20,80)"})
        		.call(node_drag)
        		.on("mouseover", function(d) { 
        
        			//d3.select(this).select("path").style("stroke-width", 6); 
        			//d3.select(this).select("path").style("stroke", "yellow"); 
        			//d3.select(this).select("text").style("font", "20px sans-serif");
        			d3.select(this).attr("class", "node highlighted");
        		
                    // Figure out the neighboring node id's with brute strength because the graph is small
                    var nodeNeighbors = graph.links.filter(function(link) {
                        // Filter the list of links to only those links that have our target 
                        // node as a source or target
                        return link.source.index === d.index || link.target.index === d.index;})
                    .map(function(link) {
                        // Map the list of links to a simple array of the neighboring indices - this is
                        // technically not required but makes the code below simpler because we can use         
                        // indexOf instead of iterating and searching ourselves.
                        return link.source.index === d.index ? link.target.index : link.source.index; });
                    
                    // select neighboring nodes and apply styles
                    svg.selectAll(".node").filter(function(node) {
                        // I filter the selection of all circles to only those that hold a node with an
                        // index in my listg of neighbors
                        return nodeNeighbors.indexOf(node.index) > -1;
                    })
        			.highlight();
        			
        			// select in and out links and apply styles
                    svg.selectAll(".link").filter(function(link) {
        				return (link.source.index === d.index || link.target.index === d.index);
                    })
        			.highlight();
        			
        			
        			// highlighting of identical resources (same URI)
        			svg.selectAll(".node").avmHighlightIdentical(d.uri);
        			
        			// extend label to full label
        			d3.select(this).selectAll("text").text(function(d){return d.full_label});			
               
        		})
        		.on("mouseout",  function(d) { 
        		
        			// TODO replacing all classes may cause problems! actually we only want to replace "node highlighted" by "node"
        			d3.select(this).select(".node").attr("class", "node");
        			d3.selectAll(".node").attr("class", "node");
        			//d3.selectAll(".link").style("stroke-width", "4px");
        			d3.selectAll(".link").attr("class", "link");
                    //d3.selectAll("path").style("stroke", "gray");
        			//d3.select(this).selectAll("path").style("stroke-width", 1.5); 
        			//d3.select(this).select("text").style("font", "12px sans-serif");
        			
        			d3.select(this).selectAll("text").text(function(d){return d.label});
        
        			})
				.on("dblclick",  function(d) { 
					d.fixed = false;	
				})
        		;
        	
        	/* node shape -> symbol */
        	var symbol = nodeEnter.append("path")
            //.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
            //.attr("d", d3.svg.symbol());
        	  .attr("class", function(d) { return "node" })
        	 .attr("d", symbolFunction)
        	 .style("fill", function(d) { return d.color_rgb_hex_combined; })
        	 ;	
        	
        	
			 /* complex labeling */
			        	
			 var nodeShapeSize = Math.sqrt(1500); /* TODO area set in symbol functions */ 
			 var labelShapeSize = nodeShapeSize/2;
			 
			 var labelContainerContainer = d3.select("#labelContainerSpace")
				.selectAll(".labelContainerContainer")
				.data(graph.nodes).enter()
				.append("div")
				.attr("class","labelContainerContainer")
				.style("height",nodeShapeSize +"px")
				.style("width",nodeShapeSize +"px");
			        		 		  	
			// SVG icon label in html div 
			
			var labelContainer1 = labelContainerContainer
				.append("div")
				.attr("class", function(d){ return "labelContainer " + d.label_position})
				.style("height",nodeShapeSize +"px")
				.style("width",nodeShapeSize +"px");
				
				labelContainer1.append("svg")
					.attr("class", "svgLabelIcon")
					.attr("width",labelShapeSize +"px")
					.attr("height",labelShapeSize +"px")
					.style("margin",-labelShapeSize/2.75 + "px")
					/*.append("svg:circle")
						.attr("r", labelShapeSize/2)
						.attr("cx",labelShapeSize/2)
						.attr("cy",labelShapeSize/2)
						.style("fill","red");*/
					.append("path")
			  			.attr("class", "label")
			 			.attr("d", labelSymbolFunction)
			 			.style("fill", "red")
						.attr("transform", function(d){ return "translate(" + labelShapeSize/2 + "," + labelShapeSize/2 + ")"})
					 ;
			        			
			// SVG text label in html div (cropped in webkit, maybe create a much bigger SVG inside the div, or modify clipping) 
			
			var labelContainer3 = labelContainerContainer
				.append("div")
				//.attr("class","labelContainer bottomLeft")
				.attr("class", function(d){ return "labelContainer " + d.label_position})
				.style("height",nodeShapeSize +"px")
				.style("width",nodeShapeSize +"px")
				;
				
				var labelContainer3SVG = labelContainer3.append("svg")
					.attr("class", "svgLabelText")
					//.attr("width",100 +"px") // are these fixed sizes sensible?
					//.attr("height",25 +"px")
					.attr("width",labelShapeSize +"px") // are these fixed sizes sensible?
					.attr("height",labelShapeSize +"px")
					//.style("margin-left",-100 + "px")
					//.style("margin-bottom",-0.2*nodeShapeSize + "px");
					
					
					// A copy of the label as shadow for better readability
			    	labelContainer3SVG.append("text")
			    		.attr("class", "nodeLabelShadow")
						.attr("x", function(d){return labelShapeSize/2})  // dx is relative positiong, x is absolute
						.attr("y", function(d){return labelShapeSize/2})
					    .text(function(d){return d.label })
						.style("text-anchor", 
							function(d){
								var labelPosition = d.label_position;
								if(labelPosition.indexOf("Right") != -1){
									return "start" ;
								} else if(labelPosition.indexOf("Left") != -1){
									return "end" ;
								}
								else return "middle" ;
							})
						;
			
					// the actual label text itself
					labelContainer3SVG.append("text")
						.attr("class", "nodeLabel") // TODO class was label ... clean up various label CSS classes
					    //.attr("dx", function(d){return 100}) // dx is relative positiong, x is absolute
						//.attr("dy", function(d){return 20})
						.attr("x", function(d){return labelShapeSize/2})  // dx is relative positiong, x is absolute
						.attr("y", function(d){return labelShapeSize/2})
					    .text(function(d){return d.label })
						//.style("text-anchor","middle") // start/middle/end -> TODO set depending on label position
						.style("text-anchor", 
							function(d){
								var labelPosition = d.label_position;
								if(labelPosition.indexOf("Right") != -1){
									return "start" ;
								} else if(labelPosition.indexOf("Left") != -1){
									return "end" ;
								}
								else return "middle" ;
							})
						;
			
			


			// HTML label  -> TODO only use this when label attachedBy containment (position = centerCenter)
			
			/*
			var labelContainer2 = labelContainerContainer
				.append("div")
				//.attr("class","labelContainer topRight")
				.attr("class", function(d){ return "labelContainer " + d.label_position})
				.style("text-align","center")
				.style("height",nodeShapeSize +"px")
				.style("width",nodeShapeSize +"px");
				
				labelContainer2
					.append("div")
			  			.attr("class", "htmlTextLabel")
						//.style("width", nodeShapeSize + "px") // does only work well for xCenter position
						.html(function(d){ return d.label})
					 ;
			*/
			        			
        			
        	/* simple node labeling and tooltips */
        		  
        	// A copy of the label as shadow for better readability
        	nodeEnter.append("text")
        		.attr("class", "nodeLabelShadow")
        	    .attr("dx", function(d){return 10})
        		.attr("dy", function(d){return 0})
        	    .text(function(d){return d.label})
        		;
			
			
			// SVG label at svg node
        	nodeEnter.append("text")
        		.attr("class", "nodeLabel")
        	    .attr("dx", function(d){return 10})
        		.attr("dy", function(d){return 0})
        	    .text(function(d){return d.label })
        	    //.text(function(d){return d.label + " lightness: " +  d.color_hsl_lightness + " rgb combined: " + d.color_rgb_hex_combined + " rgb pure: " + d.color_rgb_hex  })
        		//.text(function(d){return d.label + " (shape: " + d.shape_d3_name + ")"})
        		;
        	
           // tooltip 
        	nodeEnter.avmTitled();
 
        	  
        	// Use elliptical arc path segments to doubly-encode directionality.
        	tick = function() {
        		
        		/* position the connector paths */
                path.attr("d", function (d) {
                    var dx = d.target.x - d.source.x,
                        dy = (d.target.y - d.source.y),
                        dr = Math.sqrt(dx * dx + dy * dy);
                    return "M" + d.source.x + "," + d.source.y + "A" + (dr - drSub) + "," + (dr - drSub) + " 0 0,1 " + d.target.x + "," + d.target.y; // an arc
					//return "M" + d.source.x + "," + d.source.y + " L" + d.target.x + "," + d.target.y; // a line
					/*
					var pathString = 
						"M" + d.source.x + "," + d.source.y +
					   " L" + (dr - drSub) + "," + (dr - drSub) +  
					   " L" + d.target.x + "," + d.target.y; 
					   // a line with extra node
					
					return pathString; 
					*/	
                });
        
        
        		/* position the connector labels */
        		/* 	
        		//connectorGroup.selectAll(".label")
        		connectorLabel
				.attr("transform", function (d) {
        			var x = d.source.x + (d.target.x - d.source.x - ICONSIZE) / 2;
        		    var y = d.source.y + (d.target.y - d.source.y - ICONSIZE) / 2;
                     return "translate(" + x + "," + y + ")";
                }); */
				
				//symbol2
				connectorLabelGroup
				.attr("transform", function (d) {
					
					
					// switch direction if not in positive x-direction
					var sx,sy,tx,ty;
					if (d.source.x <= d.target.x ) {
						sx = d.source.x;
						sy = d.source.y;
						tx = d.target.x;
						ty = d.target.y;
					} else {
						sx = d.target.x;
						sy = d.target.y;
						tx = d.source.x;
						ty = d.source.y;
					}
					
					var dx = tx - sx,
                        dy = (ty - sy),
                        dr = Math.sqrt(dx * dx + dy * dy);
					
        			var xmid = sx + (dx - ICONSIZE) / 2;
        		    var ymid = sy + (dy - ICONSIZE) / 2;
					
					var c = manualArcLabelPositionCorrection;
					
					var m = -(dx/dy);
					
					var b = Math.sqrt((c*c)/(m*m+1));
					var a = Math.sqrt((c*c)-b*b); 
					
					// hack: strech for larger node distances
					b = b*0.005*dr;
					a = a*0.005*dr;
					
					//mInfo.html("m = " + m + "<br> b = " + b + "<br>a = " + a);
					
					// adapt position differently depending on 4 quadrants
					var x,y;
					if (d.source.x <= d.target.x) {
						if (m > 0) {
							x = xmid - b;
							y = ymid - a;
						}
						else if (m <= 0) {
							x = xmid + b;
							y = ymid - a;
						}
					}
					else {
						if (m < 0) {
							x = xmid - b;
							y = ymid + a;
						}
						else if (m >= 0) {
							x = xmid + b;
							y = ymid + a;
						}
					} 

                  return "translate(" + x + "," + y + ")";
                });
        
		        labelContainerContainer
				.style("top", function(d){
					return d.y - nodeShapeSize/2 + "px";
				})
				.style("left", function(d){
					return d.x -nodeShapeSize/2 + "px";
				});
		        
				/* position the nodes */
		        nodeEnter.attr("transform", function (d) {
		            return "translate(" + d.x + "," + d.y + ")";
		        });
        
            };
			
			force.on("tick", tick);

        });
                                                                        
    
        </script>
		
		
        <!-- somehow MUST NOT be before the script! -->
        <svg id="svg-effects">
            <filter id="blur-effect-1">
                <feGaussianBlur stdDeviation="0.9" />
            </filter>
            <filter id="blur-effect-2">
                <feGaussianBlur stdDeviation="2" />
            </filter>
            <defs>
                <marker id="markerSquare" markerWidth="7" markerHeight="7" refx="4" refy="4" orient="auto">
                    <rect x="1" y="1" width="5" height="5" style="stroke: none; fill:#000000;"/>
                </marker>
                <marker id="markerArrow" markerWidth="13" markerHeight="13" refx="2" refy="7" orient="auto">
                    <path d="M2,2 L2,13 L8,7 L2,2" style="fill: #000000;"/>
                </marker>
            </defs>
        </svg>
		
		
    </body>
</html>
