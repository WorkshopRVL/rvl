<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
        <link type="text/css" rel="stylesheet" href="../../css/main.css"/>
        <script type="text/javascript" src="../../js/d3.min.js">
        </script>
        <style type="text/css">
        </style>
    </head>
    <body>
        <div id="body">
        </div>
        <script type="text/javascript">
            /* after an example from http://jsfiddle.net/Y9Qq3/2/ http://jsfiddle.net/Y9Qq3/2/ */
            
            var drawLinks = true; // choose whether only nodes should be drawn and layouted
            	
            
            var width = 1400,
                height = 1200,
            	markerWidth = 3,
                markerHeight = 3,
                cRadius = 12,
                refX = cRadius + (markerWidth * 2),
                refY = -Math.sqrt(cRadius),
                drSub = cRadius + refY,
				manualArcLabelPositionCorrection = 27,
				ICONSIZE = 0; // TODO does not actually work. hack!
            ;
            
            					 
            
            	
            
            //var color = d3.scale.category20();
            
            var force = self.force = d3.layout.force()
                .charge(-900)
                .linkDistance(200)
                .size([width, height])
            	;
				
			var mInfo = d3.select("body").append("div");
            
            var svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height);
				
				
            	
            	
            	
            // Define Markers to be used in arrow paths
            svg.append("svg:defs").selectAll("marker")
               	//.data(["suit", "licensing", "resolved"])
            	.data(["link"])
                .enter().append("svg:marker")
                .attr("id", String)
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", refX)
                .attr("refY", refY)
                .attr("markerWidth", markerWidth)
                .attr("markerHeight", markerHeight)
                .attr("orient", "auto")
                .append("svg:path")
                .attr("d", "M0,-5L10,0L0,5");
            
            d3.json("../../gen/json/graph-data.json", function(error, graph) {
			//d3.json("graph-data-1.json", function(error, graph) {
            	
            	 var symbolFunction = d3.svg.symbol()
             						.size(1500)
             						.type(function (d) {return d.shape_d3_name})
									//.type("cross")
            						;
            	
            	  var forceVar = force
            	      .nodes(graph.nodes);
            	  if(drawLinks) forceVar.links(graph.links)
            	  forceVar.start();
            		  
            		  
            	 /* links / edges with label and tooltip */
            
            		var connectorGroup = svg.selectAll(".connectorGroup")
                    .data(graph.links)
                    .enter().append("svg:g")
                    .attr("class", function (d) { return "connectorGroup link" + d.type; })  
            		;
            		
            		// var path = svg.selectAll(".link")
                    //.data(graph.links)
                    var path = connectorGroup.append("svg:path")
                    .attr("class", function (d) { return "link link" + d.type; })  
            		//.style("stroke", function(d) { return d.color_rgb_hex; })
            		.style("stroke", function(d) { return d.color_rgb_hex_combined; })
            		.attr("marker-end", function (d) {
                    	//return "url(#" + d.type + ")";
            			return "url(#" + "link" + ")";
                	})
					.attr("marker-mid", function (d) {
            			return "url(#" + "markerSquare" + ")";
                	})
					.attr("id", function(d){
                    	return d.source.index + "_" + d.target.index;
                	})
            		;
					
					/* alternative: label aligned at the connector path */

					 var path_label = svg.append("svg:g").selectAll(
				    ".path_label").data(force.links()).enter()
				    .append("svg:text").attr("class",
				        "path_label").append(
				        "svg:textPath").attr(
				        "startOffset", "50%").attr(
				        "text-anchor", "middle").attr(
				        "xlink:href", function (d) {
				            return "#" + d.source.index +
				                "_" + d.target.index;
				        }).style("fill", "#fff").style(
				        "font-family", "Arial").text(
				        function (d) {
				            return d.label;
				        });
            		
            		var connectorLabelGroup = connectorGroup.append("svg:g")
            		.attr("class", "label")
            		;
					

            
            		var connectorLabelSymbol = connectorLabelGroup.append("path")
            		 .attr("class", function(d) { return "connectorLabelGroup" })
        			 .attr("d", symbolFunction)
        			 .style("fill", function(d) { return d.color_rgb_hex_combined; })
        			 ;	
					 
					var connectorLabelText = connectorLabelGroup.append("text")
            		.attr("class", "label")
            	    //.attr("dx", function(d){return 100})
            		//.attr("dy", function(d){return 100})
            	    .text(function(d){return d.label + " (" + d.type + ")" })
            		;
            		
            		//path.append("svg:title")
            	    //  .text(function(d) { return d.label; });
					
					
					
					/* manual node psoitioning */
					
					  var node_drag = d3.behavior.drag()
				        .on("dragstart", dragstart)
				        .on("drag", dragmove)
				        .on("dragend", dragend);
						
						function dragstart(d, i) {
				        forceVar.stop() // stops the force auto positioning before you start dragging
				    }
				
				    function dragmove(d, i) {
				        d.px += d3.event.dx;
				        d.py += d3.event.dy;
				        d.x += d3.event.dx;
				        d.y += d3.event.dy; 
				        tick(); // this is the key to make it work together with updating both px,py,x,y on d !
				    }
				
				    function dragend(d, i) {
				        d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
				        tick();
				        forceVar.resume();
				    }

            		  
            		              		  /*
            	  var link = svg.selectAll(".link")
            	      .data(graph.links)
            	    .enter().append("line")
            	      .attr("class", "link")
            	      //.style("stroke-width", function(d) { return Math.sqrt(d.value); })
            		  .style("stroke", function(d) { return d.color_rgb_hex; })
            		  .style("stroke-width", function(d) { return 10 })
            		  ;
            		  */
            	
            	  /* nodes */ 
            	
                	var elemEnter = svg.selectAll(".node")
            	      .data(graph.nodes).enter()
            	    .append("g")
            		.attr("class", "node")
            	    //.attr("transform", function(d){return "translate("+d.x+",80)"})
            		//.attr("transform", function(d){return "translate(+20,80)"})
            		.call(node_drag)
            		
            		.on("mouseover", function(d) { 
            
            			//d3.select(this).select("path").style("stroke-width", 6); 
            			//d3.select(this).select("path").style("stroke", "yellow"); 
            			//d3.select(this).select("text").style("font", "20px sans-serif");
            			d3.select(this).attr("class", "node highlighted");
            		
                        // Figure out the neighboring node id's with brute strength because the graph is small
                        var nodeNeighbors = graph.links.filter(function(link) {
                            // Filter the list of links to only those links that have our target 
                            // node as a source or target
                            return link.source.index === d.index || link.target.index === d.index;})
                        .map(function(link) {
                            // Map the list of links to a simple array of the neighboring indices - this is
                            // technically not required but makes the code below simpler because we can use         
                            // indexOf instead of iterating and searching ourselves.
                            return link.source.index === d.index ? link.target.index : link.source.index; });
                        
                        // select neighboring nodes and apply styles
                        svg.selectAll(".node").filter(function(node) {
                            // I filter the selection of all circles to only those that hold a node with an
                            // index in my listg of neighbors
                            return nodeNeighbors.indexOf(node.index) > -1;
                        })
                        //.style("stroke", "yellow");
            			.attr("class", "node highlighted");
            			
            			// select in and out links and apply styles
                        svg.selectAll(".link").filter(function(link) {
            				return (link.source.index === d.index ||Â link.target.index === d.index);
                        })
                        //.style("stroke-width", "8px");
            			.attr("class", "link highlighted");
            			
            			
            			// highlighting of identical resources (same URI)
            			var nodesWithSameURI = graph.nodes.filter(function(node) {
                            // Filter the list of links to only those links that have our target 
                            // node as a source or target
                            return node.uri === d.uri;})
                       .map(function(node) {
                            // Map the list of nodes to a simple array of the same-URI-nodes-indices
                            return node.index })
            				;
            				
                        svg.selectAll(".node").filter(function(node) {
                            // I filter the selection of all circles to only those that hold a node with an
                            // index in my listg of neighbors
                            return nodesWithSameURI.indexOf(node.index) > -1;
                        })
            			.attr("class", "node highlighted identical");
            			//.style("stroke", "red");
            			
            			// extend label to full label
            			d3.select(this).selectAll("text").text(function(d){return d.full_label});			
                   
            		})
            		.on("mouseout",  function(d) { 
            		
            			// TODO replacing all classes may cause problems! actually we only want to replace "node highlighted" by "node"
            			d3.select(this).select(".node").attr("class", "node");
            			d3.selectAll(".node").attr("class", "node");
            			//d3.selectAll(".link").style("stroke-width", "4px");
            			d3.selectAll(".link").attr("class", "link");
                        //d3.selectAll("path").style("stroke", "gray");
            			//d3.select(this).selectAll("path").style("stroke-width", 1.5); 
            			//d3.select(this).select("text").style("font", "12px sans-serif");
            			
            			d3.select(this).selectAll("text").text(function(d){return d.label});
            
            			})
					.on("dblclick",  function(d) { 
						d.fixed = false;	
					})
            		
            		;
            	
            	/* node shape -> symbol */
            	
            	var symbol = elemEnter.append("path")
                //.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
                //.attr("d", d3.svg.symbol());
            	  .attr("class", function(d) { return "node" })
            	 .attr("d", symbolFunction)
            	 .style("fill", function(d) { return d.color_rgb_hex_combined; })
            	 ;	
            	
            	/*
            	  var circle = 
            	  //svg.selectAll(".node")
            	    //  .data(graph.nodes)
            	      //.enter().
            		  elemEnter.append("svg:circle")
            	      .attr("class", function(d) { return "node " + d.shape_d3_name; })
            	      .attr("r", function(d) { return d.width; })
            	      //.style("fill", function(d) { return d.color_rgb_hex; })
            		  //.style("fill", function(d) { return "hsl(120,100%,50%)"; })
            		  .style("fill", function(d) { return d.color_rgb_hex_combined; })
            		  ;
            		  */
            		  	
            			
            	/* node labeling and tooltips */
            		  
            	// A copy of the label as shadow for better readability
            	elemEnter.append("text")
            		.attr("class", "nodeLabelShadow")
            	    .attr("dx", function(d){return 10})
            		.attr("dy", function(d){return 0})
            	    .text(function(d){return d.label})
            		;
            
            	elemEnter.append("text")
            		.attr("class", "nodeLabel")
            	    .attr("dx", function(d){return 10})
            		.attr("dy", function(d){return 0})
            	    .text(function(d){return d.label })
            	    //.text(function(d){return d.label + " lightness: " +  d.color_hsl_lightness + " rgb combined: " + d.color_rgb_hex_combined + " rgb pure: " + d.color_rgb_hex  })
            		//.text(function(d){return d.label + " (shape: " + d.shape_d3_name + ")"})
            		;
            	
               elemEnter.append("svg:title")
            	      .text(function(d) { return d.full_label; });
            	
            	/*
            	  force.on("tick", function() {
            	    link.attr("x1", function(d) { return d.source.x; })
            	        .attr("y1", function(d) { return d.source.y; })
            	        .attr("x2", function(d) { return d.target.x; })
            	        .attr("y2", function(d) { return d.target.y; });
            	
            	  //  circle.attr("cx", function(d) { return d.x; })
            	    //    .attr("cy", function(d) { return d.y; });
            			
            		elemEnter.attr("transform", function(d){return "translate("+d.x+","+d.y+")" });
            	  });
            	  
            	  */
            	  
            	  
            	  // Use elliptical arc path segments to doubly-encode directionality.
                //function tick() {
            	tick = function() {
            		
            		/* position the connector paths */
                    path.attr("d", function (d) {
                        var dx = d.target.x - d.source.x,
                            dy = (d.target.y - d.source.y),
                            dr = Math.sqrt(dx * dx + dy * dy);
                        return "M" + d.source.x + "," + d.source.y + "A" + (dr - drSub) + "," + (dr - drSub) + " 0 0,1 " + d.target.x + "," + d.target.y; // an arc
						//return "M" + d.source.x + "," + d.source.y + " L" + d.target.x + "," + d.target.y; // a line
						/*
						var pathString = 
							"M" + d.source.x + "," + d.source.y +
						   " L" + (dr - drSub) + "," + (dr - drSub) +  
						   " L" + d.target.x + "," + d.target.y; 
						   // a line with extra node
						
						return pathString; 
						*/	
                    });
            
            
            		/* position the connector labels */
            		/*var ICONSIZE = 200;
					
					//connectorGroup.selectAll(".label")
            		connectorLabel
					.attr("transform", function (d) {
            			var x = d.source.x + (d.target.x - d.source.x - ICONSIZE) / 2;
            		    var y = d.source.y + (d.target.y - d.source.y - ICONSIZE) / 2;
                         return "translate(" + x + "," + y + ")";
                    });
					*/
					
					//symbol2
					connectorLabelGroup
					.attr("transform", function (d) {
						
						
						// switch direction if not in positive x-direction
						var sx,sy,tx,ty;
						if (d.source.x <= d.target.x ) {
							sx = d.source.x;
							sy = d.source.y;
							tx = d.target.x;
							ty = d.target.y;
						} else {
							sx = d.target.x;
							sy = d.target.y;
							tx = d.source.x;
							ty = d.source.y;
						}
						
						var dx = tx - sx,
                            dy = (ty - sy),
                            dr = Math.sqrt(dx * dx + dy * dy);
						
            			var xmid = sx + (dx - ICONSIZE) / 2;
            		    var ymid = sy + (dy - ICONSIZE) / 2;
						
						var c = manualArcLabelPositionCorrection;
						
						var m = -(dx/dy);
						
						var b = Math.sqrt((c*c)/(m*m+1));
						var a = Math.sqrt((c*c)-b*b); 
						
						// hack: strech for larger node distances
						b = b*0.005*dr;
						a = a*0.005*dr;
						
						//mInfo.html("m = " + m + "<br> b = " + b + "<br>a = " + a);
						
						// adapt position differently depending on 4 quadrants
						var x,y;
						if (d.source.x <= d.target.x) {
							if (m > 0) {
								x = xmid - b;
								y = ymid - a;
							}
							else if (m <= 0) {
								x = xmid + b;
								y = ymid - a;
							}
						}
						else {
							if (m < 0) {
								x = xmid - b;
								y = ymid + a;
							}
							else if (m >= 0) {
								x = xmid + b;
								y = ymid + a;
							}
						} 

                      return "translate(" + x + "," + y + ")";
                    });
            
            		/* position the nodes */
                    elemEnter.attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    });
            
                   /* text.attr("transform", function (d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    });*/
                };
				
				force.on("tick", tick);
            	  
            
            });
                                                            
                                                        
                                            
                                
                    
        </script>
		
        <!-- somehow MUST NOT be before the script! -->
        <svg id="svg-effects">
            <filter id="blur-effect-1">
                <feGaussianBlur stdDeviation="0.9" />
            </filter>
            <filter id="blur-effect-2">
                <feGaussianBlur stdDeviation="2" />
            </filter>
			<defs>
  <marker id="markerSquare" markerWidth="7" markerHeight="7" refx="4" refy="4"
          orient="auto">
      <rect x="1" y="1" width="5" height="5" style="stroke: none; fill:#000000;"/>
  </marker>

  <marker id="markerArrow" markerWidth="13" markerHeight="13" refx="2" refy="7"
          orient="auto">
      <path d="M2,2 L2,13 L8,7 L2,2" style="fill: #000000;" />
  </marker>
</defs>
        </svg>
    </body>
</html>