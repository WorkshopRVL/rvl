<!DOCTYPE html>
<meta charset="utf-8">
<style>

/* siehe auch http://jsfiddle.net/Y9Qq3/2/ http://jsfiddle.net/Y9Qq3/2/ */

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
	fill: none;
    stroke: #999;
    stroke-opacity: .6;
    stroke-width: 4px;
}

marker#link {
    fill: #999;
}

text.nodeLabel {
  fill: black;
  /*stroke: white;
  //stroke-width: 1px;*/
  font-family: Arial;
}

text.nodeLabelShadow {
    stroke: white;
    stroke-width: 4px;
    stroke-opacity: .8;
	font-family: Arial;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = 800,
    height = 800,
	markerWidth = 3,
    markerHeight = 3,
    cRadius = 12,
    refX = cRadius + (markerWidth * 2),
    refY = -Math.sqrt(cRadius)
    drSub = cRadius + refY
;
	

//var color = d3.scale.category20();

var force = d3.layout.force()
    .charge(-900)
    .linkDistance(100)
    .size([width, height])
	;

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);
	
	
	
// Define Markers to be used in arrow paths
svg.append("svg:defs").selectAll("marker")
   	//.data(["suit", "licensing", "resolved"])
	.data(["link"])
    .enter().append("svg:marker")
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", refX)
    .attr("refY", refY)
    .attr("markerWidth", markerWidth)
    .attr("markerHeight", markerHeight)
    .attr("orient", "auto")
    .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");

d3.json("data.json", function(error, graph) {
	  force
	      .nodes(graph.nodes)
	      .links(graph.links)
	      .start();
		  
		  /*
	  var link = svg.selectAll(".link")
	      .data(graph.links)
	    .enter().append("line")
	      .attr("class", "link")
	      //.style("stroke-width", function(d) { return Math.sqrt(d.value); })
		  .style("stroke", function(d) { return d.color_rgb_hex; })
		  .style("stroke-width", function(d) { return 10 })
		  ;
		  */
		  
		 var path = svg.selectAll(".link")
        .data(graph.links)
        .enter().append("svg:path")
		.attr("class", "link")
        //.attr("class", function (d) { return "link " + d.type; })  
		.style("stroke", function(d) { return d.color_rgb_hex; })
		.attr("marker-end", function (d) {
        	//return "url(#" + d.type + ")";
			return "url(#" + "link" + ")";
    	})
		;
		
		path.append("svg:title")
	      .text(function(d) { return d.label; });
	

	    /*Create and place the "blocks" containing the circle and the text */  
    	var elemEnter = svg.selectAll(".node")
	      .data(graph.nodes).enter()
	    .append("g")
		//.attr("class", "node")
	    //.attr("transform", function(d){return "translate("+d.x+",80)"})
		//.attr("transform", function(d){return "translate(+20,80)"})
		.call(force.drag)
		;
	
	  var circle = 
	  //svg.selectAll(".node")
	    //  .data(graph.nodes)
	      //.enter().
		  elemEnter.append("svg:circle")
	      //.attr("class", "node")
	      .attr("r", cRadius)
	      .style("fill", function(d) { return d.color_rgb_hex; })
		  ;
		  
		  	
		  
	// A copy of the label as shadow for better readability
	elemEnter.append("text")
		.attr("class", "nodeLabelShadow")
	    .attr("dx", function(d){return 10})
		.attr("dy", function(d){return 0})
	    .text(function(d){return d.label})
		//.attr("fill", "black")
		;

		elemEnter.append("text")
		.attr("class", "nodeLabel")
	    .attr("dx", function(d){return 10})
		.attr("dy", function(d){return 0})
	    .text(function(d){return d.label + " (shape: " + d.shape_d3_name + ")"})
		;
		
		
	
   elemEnter.append("svg:title")
	      .text(function(d) { return d.full_label; });
	
	/*
	  force.on("tick", function() {
	    link.attr("x1", function(d) { return d.source.x; })
	        .attr("y1", function(d) { return d.source.y; })
	        .attr("x2", function(d) { return d.target.x; })
	        .attr("y2", function(d) { return d.target.y; });
	
	  //  circle.attr("cx", function(d) { return d.x; })
	    //    .attr("cy", function(d) { return d.y; });
			
		elemEnter.attr("transform", function(d){return "translate("+d.x+","+d.y+")" });
	  });
	  
	  */
	  
	  
	  // Use elliptical arc path segments to doubly-encode directionality.
    //function tick() {
	force.on("tick", function() {
        path.attr("d", function (d) {
            var dx = d.target.x - d.source.x,
                dy = (d.target.y - d.source.y),
                dr = Math.sqrt(dx * dx + dy * dy);
            return "M" + d.source.x + "," + d.source.y + "A" + (dr - drSub) + "," + (dr - drSub) + " 0 0,1 " + d.target.x + "," + d.target.y;
        });

        elemEnter.attr("transform", function (d) {
            return "translate(" + d.x + "," + d.y + ")";
        });

       /* text.attr("transform", function (d) {
            return "translate(" + d.x + "," + d.y + ")";
        });*/
    });
	  

});

</script>
